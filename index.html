<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Atomic Voxel - Hypercube Gematria Model Explorer</title>
    <style>body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;background-color:#f4f4f9;color:#333;margin:0;padding:20px}.container{max-width:1200px;margin:0 auto;background:#fff;padding:20px;border-radius:8px;box-shadow:0 4px 10px rgba(0,0,0,.1)}h1,h2{text-align:center;color:#2c3e50;border-bottom:2px solid #e0e0e0;padding-bottom:10px;margin-bottom:20px}.main-content{display:flex;flex-wrap:wrap;gap:30px}.analyzer{flex:1;min-width:350px}.visualization-area{flex:1.5;min-width:450px;display:flex;flex-direction:column;align-items:center}.controls{margin-bottom:20px}.controls label{display:block;margin-bottom:10px;font-weight:bold;font-size:1.1em}.slider{width:100%;cursor:pointer;height:8px}.number-input{width:80px;padding:8px;font-size:1.1em;text-align:center;border:1px solid #ccc;border-radius:4px;margin-left:10px}.results-table{width:100%;border-collapse:collapse;margin-top:15px}.results-table td{padding:12px;border:1px solid #e0e0e0;vertical-align:middle}.results-table td:first-child{font-weight:bold;background-color:#f9fafb;width:40%}#binaryVector{font-family:'Courier New',Courier,monospace;font-weight:bold;letter-spacing:2px;font-size:1.1em}#containedAxioms{font-size:1.4em;font-family:serif}#visualization{width:100%;max-width:550px;height:auto}</style>
</head>
<body>

    <div class="container">
        <h1>Atomic Voxel - Hypercube Gematria Model</h1>
        <div class="main-content">
            <div class="analyzer">
                <h2>Voxel State Analyzer</h2>
                <div class="controls">
                    <label for="voxelInput">Select a state from 0 to 4095:</label>
                    <input type="range" id="voxelSelector" class="slider" min="0" max="4095" value="1">
                    <input type="number" id="voxelInput" class="number-input" min="0" max="4095" value="1">
                </div>
                <hr>
                <table class="results-table">
                    <tr><td>Selected Value:</td><td id="displayValue"></td></tr>
                    <tr><td>Binary Vector (MSB > LSB):</td><td id="binaryVector"></td></tr>
                    <tr><td>Symmetry Complement:</td><td id="complementValue"></td></tr>
                    <tr><td>Hamming Weight (k):</td><td id="hammingWeight"></td></tr>
                    <tr><td>Vector Type:</td><td id="letterMatch"></td></tr>
                    <tr><td>Contained Axioms:</td><td id="containedAxioms"></td></tr>
                </table>
            </div>
            <div class="visualization-area">
                <h2>System Visualization</h2>
                <svg id="visualization" viewbox="0 0 500 520"></svg>
            </div>
        </div>
    </div>

    <script>
        const STRUCTURAL_VECTOR_MAP = {};

        const AXIOM_DEFINITIONS = [
            { letter: 'א', name: 'Aleph', vector: 1 << 0 },   // 1 (LSB)
            { letter: 'ב', name: 'Bet', vector: 1 << 1 },     // 2
            { letter: 'ג', name: 'Gimel', vector: 1 << 2 },   // 4
            { letter: 'ד', name: 'Dalet', vector: 1 << 3 },   // 8
            { letter: 'ה', name: 'Heh', vector: 1 << 4 },     // 16
            { letter: 'ו', name: 'Vav', vector: 1 << 5 },     // 32
            { letter: 'ז', name: 'Zayin', vector: 1 << 6 },   // 64
            { letter: 'ח', name: 'Het', vector: 1 << 7 },     // 128
            { letter: 'ט', name: 'Tet', vector: 1 << 8 },     // 256
            { letter: 'י', name: 'Yod', vector: 1 << 9 },     // 512
            { letter: 'כ', name: 'Kaf', vector: 1 << 10 },    // 1024
            { letter: 'ל', name: 'Lamed', vector: 1 << 11 }   // 2048 (MSB)
        ];
        AXIOM_DEFINITIONS.forEach(axiom => STRUCTURAL_VECTOR_MAP[axiom.vector] = { ...axiom, type: 'Axiom' });

        const COMPOUND_DEFINITIONS = [
            { letter: 'מ', name: 'Mem', vector: (1 << 4) | (1 << 0) },   // Heh + Aleph
            { letter: 'נ', name: 'Nun', vector: (1 << 5) | (1 << 1) },   // Vav + Bet
            { letter: 'ס', name: 'Samekh', vector: (1 << 6) | (1 << 2) }, // Zayin + Gimel
            { letter: 'ע', name: 'Ayin', vector: (1 << 7) | (1 << 3) },   // Het + Dalet
            { letter: 'פ', name: 'Pe', vector: (1 << 8) | (1 << 4) },     // Tet + Heh
            { letter: 'צ', name: 'Tzadi', vector: (1 << 9) | (1 << 5) },   // Yod + Vav
            { letter: 'ק', name: 'Qof', vector: (1 << 10) | (1 << 6) },  // Kaf + Zayin
            { letter: 'ר', name: 'Resh', vector: (1 << 11) | (1 << 7) },  // Lamed + Het
            { letter: 'ש', name: 'Shin', vector: (1 << 0) | (1 << 1) }    // Aleph + Bet
        ];
        COMPOUND_DEFINITIONS.forEach(compound => STRUCTURAL_VECTOR_MAP[compound.vector] = { ...compound, type: 'Compound' });
        
        STRUCTURAL_VECTOR_MAP[4095] = { letter: 'ת', name: 'Tav', type: 'Fullness' };
        
        const sliderInput = document.getElementById('voxelSelector');
        const numberInput = document.getElementById('voxelInput');
        const svgCanvas = document.getElementById('visualization');
        const svgNamespace = "http://www.w3.org/2000/svg";

        sliderInput.addEventListener('input', (event) => {
            const value = parseInt(event.target.value, 10);
            numberInput.value = value;
            updateSystemState(value);
        });

        numberInput.addEventListener('input', (event) => {
            let value = parseInt(event.target.value, 10);
            if (isNaN(value)) value = 0;
            value = Math.max(0, Math.min(4095, value));
            sliderInput.value = value;
            updateSystemState(value);
        });

        const to12BitBinaryString = (decimalValue) => decimalValue.toString(2).padStart(12, '0');
        const getSymmetryComplement = (decimalValue) => 4095 - decimalValue;
        const getHammingWeight = (binaryString) => (binaryString.match(/1/g) || []).length;

        function getVectorType(decimalValue) {
            const letterInfo = STRUCTURAL_VECTOR_MAP[decimalValue];
            if (letterInfo) {
                return `${letterInfo.type}: ${letterInfo.name} (${letterInfo.letter})`;
            }
            if (decimalValue === 0) return 'Void (Origin)';
            return 'Composite Vector';
        }

        function getContainedAxiomLetters(decimalValue) {
            if (decimalValue === 0) return '-';
            let axiomLetters = [];
            AXIOM_DEFINITIONS.forEach(axiom => {
                if ((decimalValue & axiom.vector) !== 0) {
                    axiomLetters.push(axiom.letter);
                }
            });
            return axiomLetters.join(', ');
        }

        function updateSystemState(currentValue) {
            const binaryString = to12BitBinaryString(currentValue);
            
            document.getElementById('displayValue').textContent = currentValue;
            document.getElementById('binaryVector').textContent = binaryString.replace(/(.{4})/g, '$1 ').trim();
            document.getElementById('complementValue').textContent = getSymmetryComplement(currentValue);
            document.getElementById('hammingWeight').textContent = getHammingWeight(binaryString);
            document.getElementById('letterMatch').textContent = getVectorType(currentValue);
            document.getElementById('containedAxioms').textContent = getContainedAxiomLetters(currentValue);
            
            drawVisualization(binaryString);
        }

        function createSVGElement(tag, attributes) {
            const svgElement = document.createElementNS(svgNamespace, tag);
            for (const key in attributes) {
                svgElement.setAttribute(key, attributes[key]);
            }
            return svgElement;
        }

        function drawVisualization(binaryString) {
            svgCanvas.innerHTML = '';
            drawAxiomNodes(binaryString);
            drawTernaryBars(binaryString);
        }

        function drawAxiomNodes(binaryString) {
            const binaryDigitsArray = binaryString.split('').reverse(); // Reverse for LSB at index 0
            const centerX = 250, centerY = 170, radius = 120;

            const title = createSVGElement('text', {
                x: centerX, y: 30, 'text-anchor': 'middle', 'font-size': '18px', 'font-weight': 'bold', fill: '#333'
            });
            title.textContent = "12 Foundational Axioms";
            svgCanvas.appendChild(title);

            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * 2 * Math.PI - (Math.PI / 2); // i=0 (Aleph) is at the top
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                const axiomData = AXIOM_DEFINITIONS[i];
                const isActive = binaryDigitsArray[i] === '1';

                svgCanvas.appendChild(createSVGElement('line', {
                    x1: centerX, y1: centerY, x2: x, y2: y, stroke: isActive ? '#888' : '#e0e0e0', 'stroke-width': 1.5
                }));

                const circle = createSVGElement('circle', {
                    cx: x, cy: y, r: 20, fill: isActive ? '#ffc107' : '#f8f8f8', stroke: '#555', 'stroke-width': 2
                });
                svgCanvas.appendChild(circle);

                const textNode = createSVGElement('text', {
                    x: x, y: y, 'text-anchor': 'middle', 'dominant-baseline': 'central',
                    'font-size': '22px', 'font-family': 'serif', fill: '#333'
                });
                textNode.textContent = axiomData.letter;
                svgCanvas.appendChild(textNode);
            }
        }

        function drawTernaryBars(binaryString) {
             const zAxisBits = binaryString.substring(0, 4);   // Bits 9-12 (MSB)
             const yAxisBits = binaryString.substring(4, 8);   // Bits 5-8
             const xAxisBits = binaryString.substring(8, 12);  // Bits 1-4 (LSB)
             
             const ternaryAxesData = [
                { label: 'X: Potential (א)', value: parseInt(xAxisBits, 2), color: '#d9534f' },
                { label: 'Y: Formation (מ)', value: parseInt(yAxisBits, 2), color: '#5bc0de' },
                { label: 'Z: Transform (ש)', value: parseInt(zAxisBits, 2), color: '#5cb85c' }
            ];
            const barWidth = 200, barHeight = 22, startX = 150, startY = 380, spacing = 40;

            ternaryAxesData.forEach((axisData, index) => {
                const yPosition = startY + index * spacing;
                const fillWidth = (axisData.value / 15) * barWidth;

                const labelNode = createSVGElement('text', {
                    x: startX - 15, y: yPosition + barHeight / 2, 'text-anchor': 'end', 'dominant-baseline': 'central', 'font-size': '14px',
                });
                labelNode.textContent = axisData.label;
                svgCanvas.appendChild(labelNode);

                svgCanvas.appendChild(createSVGElement('rect', {
                    x: startX, y: yPosition, width: barWidth, height: barHeight, fill: '#eee', rx: 4, ry: 4
                }));

                if (fillWidth > 0) {
                    svgCanvas.appendChild(createSVGElement('rect', {
                        x: startX, y: yPosition, width: fillWidth, height: barHeight, fill: axisData.color, rx: 4, ry: 4
                    }));
                }

                const valueNode = createSVGElement('text', {
                    x: startX + barWidth + 15, y: yPosition + barHeight / 2, 'dominant-baseline': 'central', 'font-size': '14px', 'font-weight': 'bold',
                });
                valueNode.textContent = `${axisData.value}/15`;
                svgCanvas.appendChild(valueNode);
            });
        }
        
        updateSystemState(parseInt(numberInput.value, 10));

    </script>

</body>
</html>
