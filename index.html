<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Atomic Voxel - Hypercube Gematria Model Explorer</title>
    <style>body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;background-color:#f4f4f9;color:#333;margin:0;padding:20px}.container{max-width:1200px;margin:0 auto;background:#fff;padding:20px;border-radius:8px;box-shadow:0 4px 10px rgba(0,0,0,.1)}h1,h2{text-align:center;color:#2c3e50;border-bottom:2px solid #e0e0e0;padding-bottom:10px;margin-bottom:20px}.main-content{display:flex;flex-wrap:wrap;gap:30px}.analyzer{flex:1;min-width:350px}.visualization-area{flex:1.5;min-width:450px;display:flex;flex-direction:column;align-items:center}.controls{margin-bottom:20px}.controls label{display:block;margin-bottom:10px;font-weight:bold;font-size:1.1em}.slider{width:100%;cursor:pointer;height:8px}.number-input{width:80px;padding:8px;font-size:1.1em;text-align:center;border:1px solid #ccc;border-radius:4px;margin-left:10px}.results-table{width:100%;border-collapse:collapse;margin-top:15px}.results-table td{padding:12px;border:1px solid #e0e0e0;vertical-align:middle}.results-table td:first-child{font-weight:bold;background-color:#f9fafb;width:40%}#binaryVector{font-family:'Courier New',Courier,monospace;font-weight:bold;letter-spacing:2px;font-size:1.1em}#containedAxioms{font-size:1.4em;font-family:serif}#visualization{width:100%;max-width:550px;height:auto}</style>
</head>
<body>

    <div class="container">
        <h1>Atomic Voxel - Hypercube Gematria Model</h1>
        <div class="main-content">
            <div class="analyzer">
                <h2>Voxel State Analyzer</h2>
                <div class="controls">
                    <label for="voxelInput">Select a state from 0 to 4095:</label>
                    <input type="range" id="voxelSelector" class="slider" min="0" max="4095" value="1">
                    <input type="number" id="voxelInput" class="number-input" min="0" max="4095" value="1">
                </div>
                <hr>
                <table class="results-table">
                    <tr><td>Selected Value:</td><td id="displayValue"></td></tr>
                    <tr><td>Binary Vector (MSB > LSB):</td><td id="binaryVector"></td></tr>
                    <tr><td>Symmetry Complement:</td><td id="complementValue"></td></tr>
                    <tr><td>Hamming Weight (k):</td><td id="hammingWeight"></td></tr>
                    <tr><td>Vector Type:</td><td id="letterMatch"></td></tr>
                    <tr><td>Contained Axioms:</td><td id="containedAxioms"></td></tr>
                </table>
            </div>
            <div class="visualization-area">
                <h2>System Visualization</h2>
                <svg id="visualization" viewbox="0 0 500 520"></svg>
            </div>
        </div>
    </div>

    <script>
        const VECTOR_MAP = {};
        const AXIOM_DEFINITIONS = [];

        // This is the single source of truth for all 22 letters.
        // Vectors are assigned systematically.
        const LETTER_DEFINITIONS = [
            // --- 12 Axioms (Simple Letters), k=1 ---
            { letter: 'א', name: 'Aleph', gematria: 1, type: 'Axiom', vector: 1 << 0 },
            { letter: 'ב', name: 'Bet', gematria: 2, type: 'Axiom', vector: 1 << 1 },
            { letter: 'ג', name: 'Gimel', gematria: 3, type: 'Axiom', vector: 1 << 2 },
            { letter: 'ד', name: 'Dalet', gematria: 4, type: 'Axiom', vector: 1 << 3 },
            { letter: 'ה', name: 'Heh', gematria: 5, type: 'Axiom', vector: 1 << 4 },
            { letter: 'ו', name: 'Vav', gematria: 6, type: 'Axiom', vector: 1 << 5 },
            { letter: 'ז', name: 'Zayin', gematria: 7, type: 'Axiom', vector: 1 << 6 },
            { letter: 'ח', name: 'Het', gematria: 8, type: 'Axiom', vector: 1 << 7 },
            { letter: 'ט', name: 'Tet', gematria: 9, type: 'Axiom', vector: 1 << 8 },
            { letter: 'י', name: 'Yod', gematria: 10, type: 'Axiom', vector: 1 << 9 },
            { letter: 'כ', name: 'Kaf', gematria: 20, type: 'Axiom', vector: 1 << 10 },
            { letter: 'ל', name: 'Lamed', gematria: 30, type: 'Axiom', vector: 1 << 11 },
            // --- 9 Compounds (Double Letters), k=2, using symmetrical axiom pairing ---
            { letter: 'מ', name: 'Mem', gematria: 40, type: 'Compound', vector: (1 << 0) | (1 << 11) }, // Aleph(1) + Lamed(12)
            { letter: 'נ', name: 'Nun', gematria: 50, type: 'Compound', vector: (1 << 1) | (1 << 10) }, // Bet(2) + Kaf(11)
            { letter: 'ס', name: 'Samekh', gematria: 60, type: 'Compound', vector: (1 << 2) | (1 << 9) }, // Gimel(3) + Yod(10)
            { letter: 'ע', name: 'Ayin', gematria: 70, type: 'Compound', vector: (1 << 3) | (1 << 8) }, // Dalet(4) + Tet(9)
            { letter: 'פ', name: 'Pe', gematria: 80, type: 'Compound', vector: (1 << 4) | (1 << 7) }, // Heh(5) + Het(8)
            { letter: 'צ', name: 'Tzadi', gematria: 90, type: 'Compound', vector: (1 << 5) | (1 << 6) }, // Vav(6) + Zayin(7)
            { letter: 'ק', name: 'Qof', gematria: 100, type: 'Compound', vector: (1 << 0) | (1 << 5) }, // Aleph + Vav (Mothers)
            { letter: 'ר', name: 'Resh', gematria: 200, type: 'Compound', vector: (1 << 4) | (1 << 9) }, // Heh + Yod
            { letter: 'ש', name: 'Shin', gematria: 300, type: 'Compound', vector: (1 << 0) | (1 << 6) }, // Aleph + Zayin (Mothers)
            // --- 1 Seal (Completion) ---
            { letter: 'ת', name: 'Tav', gematria: 400, type: 'Seal of Creation', vector: 4095 }
        ];

        // Populate the lookup maps from the single source of truth.
        LETTER_DEFINITIONS.forEach(def => {
            VECTOR_MAP[def.vector] = def;
            if (def.type === 'Axiom') {
                AXIOM_DEFINITIONS.push(def);
            }
        });

        const sliderInput = document.getElementById('voxelSelector');
        const numberInput = document.getElementById('voxelInput');
        const svgCanvas = document.getElementById('visualization');
        const svgNamespace = "http://www.w3.org/2000/svg";

        sliderInput.addEventListener('input', e => {
            numberInput.value = e.target.value;
            updateSystemState(parseInt(e.target.value, 10));
        });
        numberInput.addEventListener('input', e => {
            let val = parseInt(e.target.value, 10);
            if(isNaN(val)) val = 0;
            val = Math.max(0, Math.min(4095, val));
            sliderInput.value = val;
            updateSystemState(val);
        });

        const toBin = d => d.toString(2).padStart(12, '0');
        const getComp = d => 4095 - d;
        const getWeight = b => (b.match(/1/g) || []).length;

        function getVectorType(dec) {
            const info = VECTOR_MAP[dec];
            if (info) return `${info.type}: ${info.name} (${info.letter}, ${info.gematria})`;
            if (dec === 0) return 'Void (Origin)';
            return 'Composite Vector';
        }

        function getContainedAxioms(dec) {
            if (dec === 0) return '-';
            return AXIOM_DEFINITIONS.filter(ax => (dec & ax.vector) !== 0).map(ax => ax.letter).join(', ');
        }

        function updateSystemState(val) {
            const bin = toBin(val);
            document.getElementById('displayValue').textContent = val;
            document.getElementById('binaryVector').textContent = bin.replace(/(.{4})/g, '$1 ').trim();
            document.getElementById('complementValue').textContent = getComp(val);
            document.getElementById('hammingWeight').textContent = getWeight(bin);
            document.getElementById('letterMatch').textContent = getVectorType(val);
            document.getElementById('containedAxioms').textContent = getContainedAxioms(val);
            drawVisualization(bin);
        }

        function createSVG(tag, attr) {
            const el = document.createElementNS(svgNamespace, tag);
            for (const k in attr) el.setAttribute(k, attr[k]);
            return el;
        }

        function drawVisualization(bin) {
            svgCanvas.innerHTML = '';
            const binRev = bin.split('').reverse();
            const cx = 250, cy = 170, r = 120;

            const title = createSVG('text', { x: cx, y: 30, 'text-anchor': 'middle', 'font-size': '18px', 'font-weight': 'bold', fill: '#333'});
            title.textContent = "12 Foundational Axioms";
            svgCanvas.appendChild(title);

            AXIOM_DEFINITIONS.forEach((axiom, i) => {
                const angle = (i / 12) * 2 * Math.PI - (Math.PI / 2) + (Math.PI / 6);
                const x = cx + r * Math.cos(angle);
                const y = cy + r * Math.sin(angle);
                const isActive = binRev[i] === '1';

                svgCanvas.appendChild(createSVG('line', { x1: cx, y1: cy, x2: x, y2: y, stroke: isActive ? '#888' : '#e0e0e0', 'stroke-width': 1.5 }));
                svgCanvas.appendChild(createSVG('circle', { cx: x, cy: y, r: 20, fill: isActive ? '#ffc107' : '#f8f8f8', stroke: '#555', 'stroke-width': 2 }));
                const text = createSVG('text', { x: x, y: y, 'text-anchor': 'middle', 'dominant-baseline': 'central', 'font-size': '22px', 'font-family': 'serif', fill: '#333' });
                text.textContent = axiom.letter;
                svgCanvas.appendChild(text);
            });
            
            const zBits = bin.substring(0, 4), yBits = bin.substring(4, 8), xBits = bin.substring(8, 12);
            const axes = [
                { l: 'X: Potential (א)', v: parseInt(xBits, 2), c: '#d9534f' },
                { l: 'Y: Formation (מ)', v: parseInt(yBits, 2), c: '#5bc0de' },
                { l: 'Z: Transform (ש)', v: parseInt(zBits, 2), c: '#5cb85c' }
            ];
            const barW = 200, barH = 22, startX = 150, startY = 380, spacing = 40;
            axes.forEach((ax, i) => {
                const yPos = startY + i * spacing;
                const fillW = (ax.v / 15) * barW;
                const label = createSVG('text', { x: startX - 15, y: yPos + barH / 2, 'text-anchor': 'end', 'dominant-baseline': 'central', 'font-size': '14px' });
                label.textContent = ax.l;
                svgCanvas.appendChild(label);
                svgCanvas.appendChild(createSVG('rect', { x: startX, y: yPos, width: barW, height: barH, fill: '#eee', rx: 4, ry: 4 }));
                if (fillW > 0) svgCanvas.appendChild(createSVG('rect', { x: startX, y: yPos, width: fillW, height: barH, fill: ax.c, rx: 4, ry: 4 }));
                const valText = createSVG('text', { x: startX + barW + 15, y: yPos + barH / 2, 'dominant-baseline': 'central', 'font-size': '14px', 'font-weight': 'bold' });
                valText.textContent = `${ax.v}/15`;
                svgCanvas.appendChild(valText);
            });
        }
        
        // Initialize the system with Aleph (1) selected.
        updateSystemState(1);
    </script>

</body>
</html>
